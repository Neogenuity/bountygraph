/*
  BountyGraph integration example (runnable)

  This script shows how an external project (DAO, freelance platform, dev tooling)
  can integrate with the BountyGraph Anchor program end-to-end:
    - initialize a graph (admin/authority)
    - create a task (bounty)
    - fund the task escrow
    - submit a proof-of-work receipt
    - claim the reward

  Usage:
    RPC_URL=https://api.devnet.solana.com npx ts-node examples/integration/example-client.ts

  Optional:
    KEYPAIR_PATH=~/.config/solana/id.json (authority keypair to use instead of ephemeral)
*/

import * as anchor from "@coral-xyz/anchor";
import {
  Connection,
  Keypair,
  LAMPORTS_PER_SOL,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionSignature,
} from "@solana/web3.js";
import { createHash } from "crypto";
import fs from "fs";
import path from "path";

type AnyIdl = anchor.Idl & { metadata?: { address?: string } };

class KeypairWallet implements anchor.Wallet {
  constructor(readonly payer: Keypair) {}

  async signTransaction(tx: Transaction): Promise<Transaction> {
    tx.partialSign(this.payer);
    return tx;
  }

  async signAllTransactions(txs: Transaction[]): Promise<Transaction[]> {
    return txs.map((tx) => {
      tx.partialSign(this.payer);
      return tx;
    });
  }

  get publicKey(): PublicKey {
    return this.payer.publicKey;
  }
}

function loadKeypairFromFile(filePath: string): Keypair {
  const raw = fs.readFileSync(filePath, "utf8");
  const secret = Uint8Array.from(JSON.parse(raw) as number[]);
  return Keypair.fromSecretKey(secret);
}

async function airdropIfNeeded(connection: Connection, pubkey: PublicKey, minSol: number) {
  const minLamports = Math.floor(minSol * LAMPORTS_PER_SOL);
  const bal = await connection.getBalance(pubkey, { commitment: "confirmed" });
  if (bal >= minLamports) return;

  const sig = await connection.requestAirdrop(pubkey, minLamports - bal);
  await connection.confirmTransaction(sig, "confirmed");
}

async function sendAndConfirm(
  connection: Connection,
  sig: TransactionSignature,
  label: string
): Promise<void> {
  const latest = await connection.getLatestBlockhash("confirmed");
  await connection.confirmTransaction(
    {
      signature: sig,
      ...latest,
    },
    "confirmed"
  );
  const tx = await connection.getTransaction(sig, { commitment: "confirmed", maxSupportedTransactionVersion: 0 });
  if (tx?.meta?.err) {
    throw new Error(`${label} failed: ${JSON.stringify(tx.meta.err)}`);
  }
}

function mustEnv(name: string, fallback?: string): string {
  const v = process.env[name] ?? fallback;
  if (!v) throw new Error(`Missing env var ${name}`);
  return v;
}

async function main() {
  const rpcUrl = mustEnv("RPC_URL", "https://api.devnet.solana.com");
  const connection = new Connection(rpcUrl, { commitment: "confirmed" });

  const keypairPath = process.env.KEYPAIR_PATH;
  const authority = keypairPath ? loadKeypairFromFile(keypairPath) : Keypair.generate();

  // External integrator roles (creator/funder and worker/agent)
  const creator = Keypair.generate();
  const agent = Keypair.generate();

  // Fund accounts on devnet for demo (skips if balances already sufficient)
  await airdropIfNeeded(connection, authority.publicKey, 2);
  await airdropIfNeeded(connection, creator.publicKey, 2);
  await airdropIfNeeded(connection, agent.publicKey, 1);

  const provider = new anchor.AnchorProvider(connection, new KeypairWallet(authority), {
    commitment: "confirmed",
  });
  anchor.setProvider(provider);

  // Load IDL generated by `anchor build`.
  // If you're consuming BountyGraph as an npm package, replace this with a direct import.
  const repoRoot = path.resolve(__dirname, "../..", "..");
  const idlPath = path.resolve(repoRoot, "target", "idl", "bountygraph.json");
  if (!fs.existsSync(idlPath)) {
    throw new Error(
      `Missing IDL at ${idlPath}. Run: (from repo root) anchor build`);
  }
  const idl = JSON.parse(fs.readFileSync(idlPath, "utf8")) as AnyIdl;

  const programId = new PublicKey(
    idl?.metadata?.address ?? "Ghm5zPnHy5yJwQ6P22NYgNVrqPokDqAV3otdut3DSbSS"
  );
  const program = new anchor.Program(idl, programId, provider);

  const [graphPda] = PublicKey.findProgramAddressSync(
    [Buffer.from("graph"), authority.publicKey.toBuffer()],
    programId
  );

  console.log("RPC:", rpcUrl);
  console.log("Program:", programId.toBase58());
  console.log("Authority:", authority.publicKey.toBase58());
  console.log("Creator:", creator.publicKey.toBase58());
  console.log("Agent:", agent.publicKey.toBase58());
  console.log("Graph PDA:", graphPda.toBase58());

  // 1) Initialize graph (idempotent-ish: will fail if already exists; in production you can fetch-first)
  try {
    const sig = await program.methods
      .initializeGraph({ maxDependenciesPerTask: 16 })
      .accounts({
        graph: graphPda,
        authority: authority.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([authority])
      .rpc();
    await sendAndConfirm(connection, sig, "initializeGraph");
    console.log("initializeGraph tx:", sig);
  } catch (e: any) {
    const msg = String(e?.message ?? e);
    // Common when re-running: account already in use
    console.warn("initializeGraph skipped/failed (ok for reruns):", msg.split("\n")[0]);
  }

  // 2) Create a task (bounty)
  const taskId = BigInt(Date.now());
  const rewardLamports = BigInt(0.2 * LAMPORTS_PER_SOL);

  const taskIdLe = Buffer.alloc(8);
  taskIdLe.writeBigUInt64LE(taskId);

  const [taskPda] = PublicKey.findProgramAddressSync(
    [Buffer.from("task"), graphPda.toBuffer(), taskIdLe],
    programId
  );

  const createSig = await program.methods
    .createTask({
      taskId: new anchor.BN(taskId.toString()),
      rewardLamports: new anchor.BN(rewardLamports.toString()),
      dependencies: [],
    })
    .accounts({
      graph: graphPda,
      authority: authority.publicKey,
      creator: creator.publicKey,
      task: taskPda,
      systemProgram: SystemProgram.programId,
    })
    // authority is provider wallet; creator is a separate signer
    .signers([creator])
    .rpc();
  await sendAndConfirm(connection, createSig, "createTask");
  console.log("createTask tx:", createSig);
  console.log("Task PDA:", taskPda.toBase58());

  // 3) Fund the escrow for the task
  const [escrowPda] = PublicKey.findProgramAddressSync(
    [Buffer.from("escrow"), taskPda.toBuffer()],
    programId
  );

  const fundSig = await program.methods
    .fundTask(new anchor.BN(rewardLamports.toString()))
    .accounts({
      task: taskPda,
      escrow: escrowPda,
      funder: creator.publicKey,
      systemProgram: SystemProgram.programId,
    })
    .signers([creator])
    .rpc();
  await sendAndConfirm(connection, fundSig, "fundTask");
  console.log("fundTask tx:", fundSig);
  console.log("Escrow PDA:", escrowPda.toBase58());

  // 4) Submit a receipt (proof-of-work) by the agent
  const workPayload = Buffer.from(`hello-world:${taskId.toString()}`);
  const workHash = createHash("sha256").update(workPayload).digest();

  const [receiptPda] = PublicKey.findProgramAddressSync(
    [Buffer.from("receipt"), taskPda.toBuffer(), agent.publicKey.toBuffer()],
    programId
  );

  const uri = `https://example.com/bountygraph/receipts/${taskId.toString()}`;

  const submitSig = await program.methods
    .submitReceipt({
      workHash: Array.from(workHash),
      uri,
    })
    .accounts({
      task: taskPda,
      receipt: receiptPda,
      agent: agent.publicKey,
      systemProgram: SystemProgram.programId,
    })
    .signers([agent])
    .rpc();
  await sendAndConfirm(connection, submitSig, "submitReceipt");
  console.log("submitReceipt tx:", submitSig);
  console.log("Receipt PDA:", receiptPda.toBase58());

  // 5) Claim reward (release funds from escrow PDA to agent)
  const before = await connection.getBalance(agent.publicKey, "confirmed");

  const claimSig = await program.methods
    .claimReward()
    .accounts({
      task: taskPda,
      escrow: escrowPda,
      agent: agent.publicKey,
      systemProgram: SystemProgram.programId,
    })
    .signers([agent])
    .rpc();
  await sendAndConfirm(connection, claimSig, "claimReward");

  const after = await connection.getBalance(agent.publicKey, "confirmed");
  console.log("claimReward tx:", claimSig);
  console.log(
    `Agent balance delta: ${(after - before) / LAMPORTS_PER_SOL} SOL (net; excludes tx fees)`
  );

  // Fetch on-chain state to show what an integrator can index / verify
  const taskAccount = await program.account.task.fetch(taskPda);
  const receiptAccount = await program.account.receipt.fetch(receiptPda);

  console.log("Task status:", taskAccount.status);
  console.log("Task completedBy:", taskAccount.completedBy?.toBase58?.() ?? taskAccount.completedBy);
  console.log("Receipt workHash (hex):", Buffer.from(receiptAccount.workHash).toString("hex"));
  console.log("Receipt uri:", receiptAccount.uri);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
